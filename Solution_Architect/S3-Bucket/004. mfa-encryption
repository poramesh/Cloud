Overview of Multi-Factor Authentication

Multi-Factor Authentication (MFA) adds an additional layer of security beyond the username and password.
The second factor of authentication is usually a code generated by:
A physical device (e.g., token-generating key card).
A software application (e.g., Google Authenticator).

1. MFA Delete

Purpose: Adds a requirement for a second factor of authentication when performing specific bucket operations in S3.
Operations that require MFA Delete:
Changing the versioning state of a bucket from enabled to suspeneded.
Permanently deleting an object version.

Key Points:
Requests for these operations must include the x-amz-mfa header.
Versioning must be enabled on the bucket for MFA Delete to be used.

***

The x-amz-mfa header is a special HTTP header used in requests to Amazon S3 when performing operations 
that require Multi-Factor Authentication (MFA). This header ensures that the request is
authorized using MFA, adding an extra layer of security.

When is x-amz-mfa Required?
The header must be included in requests for specific operations in Amazon S3 when MFA Delete is enabled on a bucket. These operations are:
Changing the versioning state of a bucket.
Permanently deleting a version of an object.


What Does the Header Contain?

The x-amz-mfa header contains:
The ARN of the MFA device (associated with the AWS account or IAM user).
The MFA code (a one-time password generated by the device or app).

Example Format: x-amz-mfa: arn:aws:iam::<account-id>:mfa/<username> <mfa-code>



How to Include x-amz-mfa in Requests

Using the AWS CLI
The AWS CLI automatically adds the x-amz-mfa header when you specify the MFA details in your command.

Example: Deleting an Object Version with MFA

aws s3api delete-object \
  --bucket <bucket-name> \
  --key <object-key> \
  --version-id <version-id> \
  --mfa "arn:aws:iam::<account-id>:mfa/<username> <mfa-code>"


w pythin


mfa_arn = 'arn:aws:iam::<account-id>:mfa/<username>'
mfa_code = '123456'  # Code from your MFA device

# Perform the delete operation
response = s3.delete_object(
    Bucket=' ur_bucket_name',
    Key='ur_object_key',
    VersionId='ur_version_id',
    MFA=f"{mfa_arn {mfa_code}"
)

***


Who can enable MFA Delete:
Only the bucket owner (AWS account that created the bucket) can enable MFA Delete.
Authentication for MFA Delete is achieved using a code from a hardware device or software application.


2. MFA Protected API Access

Purpose: Enforces MFA when accessing AWS resources (including but not limited to S3) using the API or CLI.

Implementation:
Achieved using the aws:MultiFactorAuthAge condition in a bucket policy.
Example policy denies access if aws:MultiFactorAuthAge is null (MFA not used).

Key Points:
How it works:
If the user authenticates with MFA, the aws:MultiFactorAuthAge attribute is included in the request.
If MFA is not used, access is denied.
Separation of Console and CLI/API Authentication:
Logging into the AWS Console with MFA does not authenticate CLI/API commands.

For CLI/API access:
A token from the MFA device must be supplied to obtain temporary security credentials.
These credentials are then used for issuing API requests.


*************
The aws:MultiFactorAuthAge condition is used in an Amazon S3 bucket policy to enforce Multi-Factor Authentication (MFA) for API or CLI requests. 
It ensures that requests are only permitted if the user has authenticated with MFA within a specified time frame.


Bucket policy example:

{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "RequireMFAForSensitiveOperations", //This statement denies access if the aws:MultiFactorAuthAge attribute is missing or not present (Null: true).
      "Effect": "Deny",
      "Principal": "*", //Set to "*" to apply the condition to all users. You can restrict this to specific IAM users or roles.
      "Action": "s3:*", //Specifies which actions are controlled by this policy. In this case, all S3 actions (s3:*) are denied.
      "Resource": [
        "arn:aws:s3:::example-bucket",
        "arn:aws:s3:::example-bucket/*"
      ],
      "Condition": {
        "Null": {
          "aws:MultiFactorAuthAge": true //The Null condition checks if the aws:MultiFactorAuthAge attribute is not included in the request. This attribute is 
present only when the request is authenticated with MFA. IF aws:MFAAGE is set to true if its NULL means its not presenet and set to FALSE if its present.
//IT IS TRUE SO IT DENIED

        }
      }
    }
  ]
}


Enhanced Example: Deny Non-MFA Access

To ensure users must use MFA and restrict access based on how recently MFA was authenticated, you can add a numeric condition with aws:MultiFactorAuthAge.

{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "DenyAccessIfNoMFA",
      "Effect": "Deny",
      "Principal": "*",
      "Action": "s3:*",
      "Resource": [
        "arn:aws:s3:::example-bucket",
        "arn:aws:s3:::example-bucket/*"
      ],
      "Condition": {
        "NumericGreaterThanIfExists": {
          "aws:MultiFactorAuthAge": 3600 //Denies the request if the time since MFA authentication (in seconds) is greater than 3600 seconds (1 hour).
        }
      }
    }
  ]
}

Effect:
The Deny effect ensures that access is explicitly denied if the condition is met (no MFA or MFA too old).

Important Considerations for Exam

MFA Delete:
Applies to specific operations: changing versioning state and permanently deleting object versions.
Requires versioning to be enabled and can only be enabled by the bucket owner.

MFA Protected API Access:
Enforced using aws:MultiFactorAuthAge in bucket policies.
MFA must be explicitly supplied for CLI/API, separate from console-based MFA.
These concepts are critical for understanding and implementing MFA in S3 and other AWS resources.



*&**&*****

MFA Authentication and Temporary Credentials

To access AWS services using the CLI or API while enforcing MFA, you need to follow these steps:

1. Authenticate with MFA to Obtain Temporary Security Credentials:

When you try to access AWS resources through the CLI or API, you must first authenticate using MFA.
This means providing a temporary code generated by an MFA device (such as a hardware token or a software-based app like Google Authenticator or AWS Virtual MFA).
The MFA device generates a time-based one-time passcode (TOTP) that must be entered during authentication.


Temporary Credentials via aws sts get-session-token:
Once you have provided the MFA token, you will call the AWS Security Token Service (STS) to obtain temporary security credentials.
This is done using the get-session-token operation. The request must include the MFA code and the MFA serial number (the ARN of your MFA device).
The AWS STS responds with temporary credentials (Access Key ID, Secret Access Key, and Session Token).


2. The CLI or API Command Flow

Here is the typical flow for obtaining temporary credentials and using them to perform AWS CLI or API actions:

Step 1: Generate the MFA Code
Open your MFA device (hardware token or app like Google Authenticator).
It will generate a one-time code, which is usually valid for 30 seconds.


Step 2: Obtain Temporary Credentials via STS
Use the aws sts get-session-token command in the CLI to get temporary credentials.

Command example:
aws sts get-session-token --serial-number arn:aws:iam::123456789012:mfa/your-mfa-device --token-code 123456

Replace arn:aws:iam::123456789012:mfa/your-mfa-device with the ARN of your MFA device and 123456 with the MFA code.


Step 3: Receive Temporary Credentials
The output will include temporary credentials, including:
Access Key ID
Secret Access Key
Session Token

Example response:
{
  "Credentials": {
    "AccessKeyId": "AKIAEXAMPLE",
    "SecretAccessKey": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
    "SessionToken": "FwoGZXIvYXJhb...",
    "Expiration": "2024-12-31T23:59:59Z"
  }
}


Step 4: Use Temporary Credentials in Subsequent CLI/API Commands

After obtaining the temporary credentials, you can use them for any AWS CLI or API request.
You set the temporary credentials as environment variables or in the AWS CLI configuration.

Example:
export AWS_ACCESS_KEY_ID=AKIAEXAMPLE
export AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
export AWS_SESSION_TOKEN=FwoGZXIvYXJhb...

After this, you can proceed with making API requests with those credentials, for example:
aws s3 ls


Why MFA for CLI/API Access?

The requirement for MFA is an added layer of security that ensures only authorized users can make API or CLI calls. Here's why it’s important:

Enhanced Security: If someone gains access to your access keys (for example, through a compromised instance or credential leak), they would still
need to authenticate via MFA to get temporary credentials.

Temporary Credentials: The temporary credentials provided by AWS STS are valid for a limited time (up to 36 hours), reducing the risk of long-term exposure.

Granular Control: MFA ensures that sensitive operations (such as deleting critical data, changing configuration settings, or managing access control) 
are only executed by users who can prove their identity via MFA.


Key Concepts to Remember
MFA Code: A time-based one-time password generated by your MFA device.
Temporary Credentials: Short-lived access credentials returned by the AWS Security Token Service (STS) when you authenticate using MFA.
Session Token: A key component of the temporary credentials, which must be included in any CLI/API calls when using MFA.
Expiration: Temporary credentials expire after a short period (from a few minutes to 36 hours).


***********$$$$$$$




The Two Factors in 2FA:

Something you know: This is typically your password or PIN.
Something you have: This could be:
A physical device (e.g., a smartphone, a hardware security key).
A code generated by an app (e.g., Google Authenticator, Authy, or Microsoft Authenticator).
A code sent via SMS or email.
A biometric factor like a fingerprint or facial recognition.

How 2FA Works:
When you try to log into a system or account with 2FA enabled, you will typically follow this process:

Step 1: Enter your password as usual. This is the first factor (something you know).

Step 2: The system will then prompt you to provide the second factor, usually a code.
If you’re using an app like Google Authenticator, it will generate a time-sensitive code that you need to enter.
If you're using SMS-based 2FA, you’ll receive a one-time passcode via text message on your phone.

Step 3: After you enter the second factor (code), the system verifies it and grants you access to the account if both factors are correct.

Example of 2FA:

Let’s say you want to log into your email account:
You enter your username and password (the first factor).
Then, you are prompted to enter the code that is sent to your phone via SMS or generated by an 
app like Google Authenticator (the second factor).

If both the password and the correct code are entered, you are granted access.


Why 2FA is Important:

Security: Even if someone steals your password (e.g., through phishing or data breach), they won’t be able to access
your account without the second factor.

Protection Against Unauthorized Access: The second factor can be something you have (your phone or hardware token), making it
much harder for attackers to gain access to your accounts.

Decreased Risk of Identity Theft: It significantly reduces the chances of hackers using stolen credentials to impersonate you.

Types of 2FA:

SMS-based 2FA: A one-time passcode is sent via text message to your phone.
Pros: Easy to set up and use.
Cons: Vulnerable to SIM swapping attacks or interception.

App-based 2FA: Apps like Google Authenticator or Authy generate time-sensitive codes (usually every 30 seconds).
Pros: More secure than SMS, since the code is generated offline on your device.
Cons: Requires installing an app and configuring it with each service.

Hardware Token: A physical device (like a USB key or key fob) that generates a code or is used directly for authentication (e.g., YubiKey).
Pros: Very secure and not susceptible to phishing or malware attacks.
Cons: Requires carrying a physical device.

Biometric Authentication: Uses unique biological traits (like a fingerprint or facial recognition) as the second factor.
Pros: Very secure and convenient.
Cons: May require special hardware or software.


HOW DUMB I WAS TO CONFUSE IT CAUSE GOOGLE AUTHENTICATOR IS BASICALLY LIKE OKTA , you need to enter the generated keys on your okta app or something. OR A PUSH NOTIFICAIOTN that 
you gotta accept TO SAY THAT YOU AE THE SMAE PERson. IT WILL HAVE 30 SEC WINDOW PERIOD WIHIN THAT YOUW ILL HAVE TO DO ITwe.







ENCRYPTION


Types of Amazon S3 Encryption:

Server-Side Encryption with S3 Managed Keys (SSE-S3):
AWS manages the encryption keys.
Uses 256-bit encryption.
Encryption and decryption occur within S3 (on AWS's side).
Objects are encrypted at rest as they are written to the disks in S3.
In-transit encryption happens using TLS when uploading and downloading objects.


Server-Side Encryption with AWS KMS Managed Keys (SSE-KMS):
Keys are managed by AWS Key Management Service (KMS).
Can use either AWS-managed keys or customer-managed keys.
Encryption and decryption happen within S3, but the keys are managed by KMS.


Server-Side Encryption with Client-Provided Keys (SSE-C):
Keys are managed by the client (not stored on AWS).
Encryption and decryption occur within S3, but the keys are not stored by AWS.


Client-Side Encryption:
The client manages the keys (not stored on AWS).
Encryption and decryption happen on the client side, not within AWS.
AWS only sees the encrypted objects and cannot decrypt them.

Encryption by Default:

S3 Encryption is enabled by default for new object uploads:
New objects are automatically encrypted using SSE-S3 (server-side encryption with S3-managed keys).
No additional cost or performance impact when using the default encryption.


Existing unencrypted objects can be encrypted:
Use S3 batch operations to encrypt existing objects.
Use Copy Objects API operation or AWS CLI command to copy and encrypt objects.



Enforcing Encryption via Bucket Policies:

You can enforce encryption settings via bucket policies.
For example, you can force SSE-KMS instead of SSE-S3.

Example policy:
Denies PutObject requests if the request does not include SSE-KMS encryption.
The policy condition checks if the x-amz-server-side-encryption header is set to AWS KMS.

Example Bucket Policy to Enforce SSE-KMS:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Deny",
      "Action": "s3:PutObject",
      "Resource": "arn:aws:s3:::your-bucket-name/*",
      "Condition": {
        "StringNotEquals": {
          "s3:x-amz-server-side-encryption": "aws:kms"
        }
      }
    }
  ]
}
This policy ensures only SSE-KMS is used for encrypting objects in the specified bucket.


PUT /my-bucket/my-object HTTP/1.1
Host: my-bucket.s3.amazonaws.com
x-amz-server-side-encryption: aws:kms
x-amz-server-side-encryption-aws-kms-key-id: arn:aws:kms:region:account-id:key/key-id ///
Content-Length: 12345
x-amz-date: 20240101T123456Z
Authorization: AWS4-HMAC-SHA256 ...





Practicals:

Enforcing Encryption with AWS KMS in S3

Overview of Encryption in S3

Default Encryption in S3 uses S3 Managed Keys (SSE-S3).
Enforcing Encryption with KMS Keys: The goal is to force encryption using AWS Key Management Service (KMS) keys instead of S3-managed keys.

S3 Bucket Policy to Enforce KMS Encryption

Bucket Policy Structure: 
Deny PUT Requests without KMS Encryption:
A condition is added to check if x-amz-server-side-encryption is not set to aws:kms. If it's not set, the PUT request is denied.

Example Bucket Policy:

{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Deny",
      "Action": "s3:PutObject",
      "Resource": "arn:aws:s3:::your-bucket-name/*",
      "Condition": {
        "StringNotEquals": {
          "s3:x-amz-server-side-encryption": "aws:kms"
        }
      }
    }
  ]
}

The condition ensures that the x-amz-server-side-encryption header in the PUT request must include aws:kms.

Steps to Implement the Policy:

Create an S3 Bucket:
Create an S3 bucket and name it (e.g., s3-encryption-test).
Copy the Bucket ARN.

Add Bucket Policy:
In the Permissions tab of the S3 bucket, click Edit.
Paste the policy that enforces the use of KMS encryption.
Save changes.

Uploading Objects:
When uploading an object, ensure that the encryption settings are correct.
Without KMS: The upload will fail because the bucket policy enforces KMS encryption.
With KMS: The upload will succeed if the KMS encryption is specified.

Choosing KMS Key:
When uploading, in the Properties section, choose KMS encryption.
AWS has a default KMS key for S3, or you can use your own KMS key ARN.
The upload will work if the KMS key is selected.

Troubleshooting Uploads:
Failure due to no KMS encryption:
When the user tries to upload without specifying KMS, it fails.
AWS will prevent uploads without KMS encryption due to the bucket policy.

Successful Upload with KMS:
Uploads will work when KMS encryption is specified, either with AWS’s default KMS key or a customer-managed key.
